import {
  Let, Id, Eq, Num, OpenParen, CloseParen, Comma, Command,
  JsOp, Def, Return, End, DataClass, New, Dot, Class, Get,
  Str, Bang, OpenSquare, CloseSquare, If, Else, PlusEq, 
  While, Do, Regex, Continue, Break, Export, Default 
} from "./lexer"

export dataclass NamedLet(name, expr)
export dataclass NumExpr(value)
export dataclass RegexNode(value)
export dataclass StrExpr(value)
export dataclass FunctionCall(lhs_expr, args)
export dataclass IdLookup(name)
export dataclass CommandExpr(name, expr)
export dataclass JsOpExpr(lhs, type, rhs)
export dataclass FunctionDef(name, args, body)
export dataclass ReturnExpr(expr)
export dataclass ContinueStatement
export dataclass BreakStatement
export dataclass NewExpr(expr)
export dataclass NotExpr(expr)
export dataclass DataClassDef(name, properties)
export dataclass DotAccess(lhs, property)
export dataclass ClassDef(name, properties, entries)
export dataclass ClassInstanceEntry(name, expr)
export dataclass ClassGetterExpr(name, expr)
export dataclass PrefixDotLookup(name)
export dataclass ArrayLiteral(elements)
export dataclass IfStatement(branches)
export dataclass IfBranch(test_expr, body)
export dataclass ElseIfBranch(test_expr, body)
export dataclass ElseBranch(body)
export dataclass NodeAssignment(lhs_expr, rhs_expr)
export dataclass NodePlusAssignment(lhs_expr, rhs_expr)
export dataclass WhileStatement(test_expr, body)
export dataclass PropertyLookup(lhs, property)
export dataclass ExportDefault(expr)
export dataclass ExportStatement(statement)

class Parser(tokens)
  index = 0
  get cur_token = .tokens[.index]
  get prev_token = .tokens[.index - 1]

  def consume(TokenClass)
    if .cur_token instanceof TokenClass
      .index += 1
      return .prev_token
    else
      parse_error! `[lexer.lang:${.cur_token.line}] Expected ${TokenClass}, got ${.cur_token.constructor}`
    end
  end

  def clone_and_parse_until(...end_tokens)
    let cloned = new Parser(.tokens)
    cloned.index = .index
    let result = cloned.parse(...end_tokens)
    .index = cloned.index
    return result
  end

  def parse(...end_tokens)
    let ast = []

    def ::has_reached_end_token
      return false if end_tokens.length === 0
      return any([.cur_token instanceof EndTokenClass for EndTokenClass in end_tokens])
    end

    while .index < .tokens.length && !has_reached_end_token() do
      let statement_or_expr = .parse_statement()

      if !statement_or_expr
        statement_or_expr = .parse_expr()

        if !statement_or_expr
          console.log(.cur_token)
          throw new ParseError()
        end
      end

      if .scan(If) && .prev_token.line === .cur_token.line
        statement_or_expr = .parse_postfix_if(statement_or_expr)
      else if .scan(If)
        throw new ParseError("Unexpected If")
      end

      ast.push(statement_or_expr)
    end

    return ast
  end

  def scan(...TokenClasses)
    let i = 0
    for let TokenClass of TokenClasses do
      return false if !(.tokens[.index + i] instanceof TokenClass)
      i += 1
    end
    return true
  end

  def parse_statement = case
    when .scan(Let) => .parse_let()
    when .scan(Def) => .parse_def()
    when .scan(DataClass) => .parse_data_class_def()
    when .scan(DataClass) => .parse_data_class_def()
    when .scan(Return) => .parse_return()
    when .scan(Continue) => .parse_continue()
    when .scan(Break) => .parse_break()
    when .scan(Class) => .parse_class()
    when .scan(If) => .parse_if()
    when .scan(While) => .parse_while()
    when .scan(Export, => hen(.parse_export_default()
    when .scan(Export) => .parse_export()
  end

  def first_parse_expr = case
    when .scan(Num) => .parse_num()
    when .scan(Regex) => .parse_regex()
    when .scan(Str) => .parse_str()
    when .scan(Id) => .parse_id_lookup()
    when .scan(Command) => .parse_command()
    when .scan(New) => .parse_new_expr()
    when .scan(Bang) => .parse_not_expr()
    when .scan(OpenSquare) => .parse_array()
    when .scan(Dot) => .parse_prefix_dot_lookup()
  end

  ASSIGNABLE_NODES = [DotAccess, PrefixDotLookup, IdLookup]
  def parse_node_assignment(lhs_expr)
    .consume(Eq)
    let rhs_expr = .parse_expr()
    return new NodeAssignment(lhs_expr, rhs_expr)
  end

  def parse_node_plus_assignment(lhs_expr)
    .consume(PlusEq)
    let rhs_expr = .parse_expr()
    return new NodePlusAssignment(lhs_expr, rhs_expr)
  end

  def parse_expr
    let expr = .first_parse_expr()
    return if !expr

    if .ASSIGNABLE_NODES.includes(expr.constructor)
      if .scan(Eq)
        return .parse_node_assignment(expr)
      else if .scan(PlusEq)
        return .parse_node_plus_assignment(expr)
      end
    end

    loop do
      if .scan(JsOp)
        expr = .parse_js_op(expr)
      else if .scan(Dot) && .prev_token.line === .cur_token.line
        expr = .parse_dot_access(expr)
      else if .scan(OpenSquare) && .prev_token.line === .cur_token.line
        expr = .parse_property_lookup(expr)
      else if .scan(OpenParen)
        expr = .parse_function_call(expr)
      else
        break
      end
    end

    return expr
  end

  parse_else_if = parser! new ElseIfBranch(
    Ignore(Else),
    Ignore(If),
    .parse_expr(),
    .clone_and_parse_until(Else, End)
  )
  parse_else = parser! new ElseBranch(
    Ignore(Else),
    .clone_and_parse_until(End)
  )
  parse_pass_branch = parser! new IfBranch(Ignore(If), .parse_expr(), .clone_and_parse_until(Else, End))
  parse_if = parser! new IfStatement(
    NoneOfMore(case
      when .scan(Else, If) => .parse_else_if(),
      when .scan(Else) => .parse_else()
    end),
    Ignore(End)
  )
  parse_postfix_if = parser! lhs => new IfStatement(
    [new IfBranch(.parse_expr(), [lhs])]
  )
  parse_array = parser! new ArrayLiteral(
    Ignore(OpenSquare),
    NoneOrMore(.parse_expr(), Optional(Comma)),
    Ignore(CloseSquare)
  )
  parse_class_entry = parser! Case(
    When(Id, Eq).Then(.parse_class_instance_entry()),
    When(Get).Then(.parse_getter()),
    When(Def).Then(.parse_def())
  )
  parse_class = parser! new ClassDef(
    Ignore(Class),
    Id({ name }),
    .parse_arg_names() if .scan(OpenParen)
    Collect(.parse_class_entry() if .cur_token && !.scan(End))
    Ignore(End)
  )
  parse_arg_names = parser! new ArgNames(
    Ignore(OpenParen),
    NoneOrMore(Id({ name }), Optional(Comma)),
    Ignore(CloseParen)
  )
  parse_data_class_def = parser! new DataClassDef(
    Id({ name }),
    .parse_arg_names() if OpenParen
  )
  parse_def = parser! new FunctionDef(
    Id({ name }),
    .parse_arg_names() if OpenParen,
    .clone_and_parse_until(End)
  )
  parse_command = parser! new CommandExpr(
    Command({ name }),
    .parse_expr()
  )
  parse_function_call = parser! expr => new FunctionCall(
    Ignore(OpenParen),
    NoneOrMore(.parse_expr(), Optional(Comma)),
    Ignore(CloseParen)
  )
  parse_export_default = parser! new ExportDefault(
    Ignore(Export, Default),
    .parse_expr()
  )
  parse_export = parser! new ExportStatement(Ignore(Export), .parse_statement())
  parse_property_lookup = parser! lhs => new PropertyLookup(
    lhs,
    Ignore(OpenSquare),
    .parse_expr(),
    Ignore(CloseSquare)
  )
  parse_while = parser! new WhileStatement(
    Ignore(While),
    .parse_expr(),
    Ignore(Do),
    .clone_and_parse_until(End)
  )
  parse_not_expr = parser! new NotExpr(Ignore(Bang), .parse_expr())
  parse_prefix_dot_lookup = parser! new PrefixDotLookup(Ignore(Dot), Id({ name }))
  parse_class_instance_entry = parser! new ClassInstanceEntry(
    Id({ name }),
    Ignore(Eq),
    .parse_expr()
  )
  parse_getter = parser! new ClassGetterExpr(
    Ignore(Get),
    Id({ name }),
    Ignore(Eq),
    .parse_expr()
  )
  parse_dot_access = parser! lhs => new DotAccess(Ignore(Dot), Id({ name }))
  parse_new_expr = parser! new NewExpr(Ignore(New), .parse_expr())
  parse_return = parser! new ReturnExpr(Ignore(Return), .parse_expr())
  parse_continue = parser! new ContinueStatement(Ignore(Continue))
  parse_break = parser! new BreakStatement(Ignore(Break))
  parse_js_op = parser! lhs_expr => new JsOpExpr(lhs_expr, JsOp({ op }), .parse_expr())
  parse_id_lookup = parser! new IdLookup(Id({ name }))
  parse_str = parser! new StrExpr(Str({ value }))
  parse_regex = parser! new RegexNode(Regex({ value }))
  parse_num = parser! new NumExpr(Num({ value }))
  parse_let = parser! new NamedLet(Ignore(Let), Id({ name }), .parse_expr())
end

export default Parser
