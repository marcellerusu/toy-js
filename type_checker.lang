import {
  IdLookup, NamedLet, NumExpr, FunctionCall, CommandExpr,
  JsOpExpr, FunctionDef, ReturnExpr, DataClassDef,
  NewExpr, DotAccess, ClassDef, ClassInstanceEntry,
  ClassGetterExpr, PrefixDotLookup, StrExpr,
  NotExpr, ArrayLiteral, IfStatement, NodeAssignment,
  NodePlusAssignment, WhileStatement, RegexNode,
  ContinueStatement, BreakStatement, IfBranch,
  ElseIfBranch, ElseBranch, PropertyLookup, ExportDefault,
  ExportStatement, SpreadExpr, SimpleArg, SpreadArg,
  ArrowFn, IsOperator, BoundFunctionDef, ForLoop,
  IsNotOperator, ParenExpr, LetObjectDeconstruction,
  RegularObjectProperty, RenamedProperty, ImportStatement,
  DefaultImport, LetArrDeconstruction, ArrNameEntry,
  ArrComma, DefaultObjClassArg, NamedClassArg, ObjClassArg,
  SimpleDefaultArg, ObjLit, SimpleObjEntry, PrefixBindLookup,
  NumberT, StrT
} from "./parser.mjs"

dataclass FnT(args, return_type)
dataclass AnyT
dataclass NilT
dataclass ObjT(properties)

let BUILTIN_TYPES = {
  console: new ObjT({ log: new FnT(new AnyT(), new NilT()) })
}

class TypeChecker(ast, types = BUILTIN_TYPES)
  def check
    for let statement of .ast do
      .check_statement(statement)
    end
    null
  end

  def check_statement(node)  
    if node is NamedLet
      .check_named_let(node)
    else if node is FunctionDef
      .check_function_def(node)
    else if node is ReturnExpr
      .check_expr(node.expr)
    else if node is FunctionCall
      .check_function_call(node)
    else
      assert_not_reached! "Unknown statement " + node.constructor.name
    end
  end

  def check_function_def({ name, args, body, type })
    let sub_types = Object.assign({}, .types)
    let tc = new TypeChecker(body, sub_types)
    type = tc.infer(body.at(-1)) if !type
    .types[name] = new FnT(args, type)
    for let arg of args do
      sub_types[arg.name] = arg.type
    end

    tc.check()
  end

  def infer(expr)
    if expr is NumExpr
      return new NumberT()
    else if expr is StrExpr
      return new StrT()
    else if expr is ReturnExpr
      return .infer(expr.expr)
    else if expr is JsOpExpr
      return .infer_js_op(expr.type).return_type
    else if expr is IdLookup      
      return .types[expr.name] if .types[expr.name]
      console.log(expr)
      assert_not_reached! "unknown type for " + expr.name
    else if expr is FunctionCall
      return .infer(expr.lhs_expr).return_type
    else if expr is DotAccess
      return .infer(expr.lhs).properties[expr.property]
    else
      assert_not_reached! "Can't infer " + expr.constructor.name
    end
  end

  def panic_mismatch(name, expected, got)
    assert_not_reached! "type mismatch: expected `" + name + "` to be a " + expected + " but it was a " + got 
  end

  def is_match(a, b)
    a.constructor === b.constructor
  end

  def infer_js_op(type)
    if type === "+"
      return new FnT([{ type: new NumberT() }, { type: new NumberT() }], new NumberT())
    else if type === "++"
      return new FnT([{ type: new StrT() }, { type: new StrT() }], new StrT())
    else
      assert_not_reached! "unknown js op type " + type
    end
  end

  def check_js_op_expr({ lhs, rhs, type })
      let lhs_t = .infer(lhs)
      let rhs_t = .infer(rhs)
      if !.is_match(lhs_t, rhs_t)
        console.log(lhs_t, rhs_t)
        assert_not_reached! "js operands don't match"
      end
      let { args, return_type } = .infer_js_op(type)
      if !.is_match(lhs_t, args[0].type)
        console.log(type, return_type)
        console.log(lhs_t, args[0].type)
        assert_not_reached! "js op arg type mismatch"
      end
      assert_not_reached! "js op return type mismatch" if !.is_match(lhs_t, return_type)
  end

  def check_expr(expr)
    if expr is FunctionCall
      .check_function_call(expr)
    else if expr is NumExpr
      null
    else if expr is StrExpr
      null
    else if expr is JsOpExpr
      .check_js_op_expr(expr)
    else
      assert_not_reached! "check_expr: Unknown nodeÂ " + expr.constructor.name
    end
  end

  def pretty(obj)
    obj.constructor.name + "(" + JSON.stringify(obj) + ")"
  end

  def check_function_call({ lhs_expr, args })
    for let arg of args do
      .check_expr(arg)
    end
    let { args: fn_arg_types } = .infer(lhs_expr)
    return null if fn_arg_types is AnyT
    assert_not_reached! "args length mismatch" if fn_arg_types.length !== args.length

    for let iter of args.zip(fn_arg_types) do
      let [value, {type}] = iter
      if !.is_match(.infer(value), type)
        .panic_mismatch(.pretty(value), type.constructor.name, .infer(value).constructor.name)
      end
    end
    null
  end

  def check_named_let({ name, expr, type })
    .check_expr(expr)
    let inferred_type = .infer(expr)
    if !type
      .types[name] = inferred_type
    else if .is_match(type, .infer(expr))
      .types[name] = type
    else
      console.log(name, type, .infer(expr))
      console.log(expr)
      .panic_mismatch(name, type.constructor.name, .infer(expr).constructor.name)
    end
  end
end

export default TypeChecker