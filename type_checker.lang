import {
  IdLookup, NamedLet, NumExpr, FunctionCall, CommandExpr,
  JsOpExpr, FunctionDef, ReturnExpr, DataClassDef,
  NewExpr, DotAccess, ClassDef, ClassInstanceEntry,
  ClassGetterExpr, PrefixDotLookup, StrExpr,
  NotExpr, ArrayLiteral, IfStatement, NodeAssignment,
  NodePlusAssignment, WhileStatement, RegexNode,
  ContinueStatement, BreakStatement, IfBranch,
  ElseIfBranch, ElseBranch, PropertyLookup, ExportDefault,
  ExportStatement, SpreadExpr, SimpleArg, SpreadArg,
  ArrowFn, IsOperator, BoundFunctionDef, ForLoop,
  IsNotOperator, ParenExpr, LetObjectDeconstruction,
  RegularObjectProperty, RenamedProperty, ImportStatement,
  DefaultImport, LetArrDeconstruction, ArrNameEntry,
  ArrComma, DefaultObjClassArg, NamedClassArg, ObjClassArg,
  SimpleDefaultArg, ObjLit, SimpleObjEntry, PrefixBindLookup,
  NumT, StrT, ArrayT, TypeDef, TypeIdLookup
} from "./parser"
import Lexer from "./lexer"
import Parser from "./parser"

dataclass FnT(args, return_type)
dataclass AnyT
dataclass NilT
dataclass ObjT(properties)
dataclass UnionT(types)
dataclass DataClassT(properties)

let BUILTIN_TYPES = {
  console: new ObjT({ log: new FnT(new AnyT(), new NilT()) })
  process: new ObjT({ argv: new ArrayT(new StrT()) })
}

class TypeChecker(ast, types = BUILTIN_TYPES)
  def check
    for let statement of .ast do
      .check_statement(statement)
    end
    null
  end

  def check_statement(node)  
    if node is NamedLet
      .check_named_let(node)
    else if node is FunctionDef
      .check_function_def(node)
    else if node is ReturnExpr
      .check_expr(node.expr)
    else if node is FunctionCall
      .check_function_call(node)
    else if node is LetArrDeconstruction
      .check_let_arr_deconstruction(node)
    else if node is DataClassDef
      .check_data_class_def(node)
    else if node is TypeDef
      .check_type_def(node)
    else
      assert_not_reached! "Unknown statement " + node.constructor.name
    end
  end

  def check_type_def({ name, type })
    .types[name] = type
    null
  end

  def check_data_class_def({ name, properties })
    assert! properties.every(p => p is NamedClassArg)
    let property_types = properties.map(p => [p.name, p.type])
    .types[name] = new DataClassT(property_types)
    null
  end

  def check_let_arr_deconstruction({ entries, rhs })
    let { type } = .infer(rhs)
    for let entry of entries do
      continue if entry is ArrComma
      if entry is ArrNameEntry
        .types[entry.name] = type
      else
        console.log(entry)
        assert_not_reached! "unknown array entry " + entry.constructor.name
      end
    end
    null
  end

  def check_function_def({ name, args, body, type })
    let sub_types = Object.assign({}, .types)
    let tc = new TypeChecker(body, sub_types)
    # infer the returned type
    # TODO: look at all return statements, not just the last one
    type = tc.infer(body.at(-1)) if !type
    # store the type
    .types[name] = new FnT(args, type)
    # store the arg types
    for let arg of args do
      sub_types[arg.name] = arg.type
    end
    # type check the function body
    tc.check()
  end

  def infer_id_lookup({ name })  
    return .types[name] if .types[name]
    assert_not_reached! "unknown type for " ++ name
  end

  def infer_dot_access({ lhs, property })
    let lhs_t = .infer(lhs)
    if lhs_t is ArrayT
      return .infer_array_method(lhs_t, property)
    else if lhs_t is ObjT
      return lhs_t.properties[property]
    else if lhs_t is NumT
      return .infer_number_method(property)
    else if lhs_t is DataClassT
      let p = lhs_t.properties.find(p => p[0] === property)
      assert! p !== undefined
      return p[1]
    else
      assert_not_reached! "unknown lhs of dot access " ++ lhs_t.constructor.name
    end
  end

  def infer_new_expr({ expr })
    assert! expr is FunctionCall
    let { lhs_expr } = expr
    let class_t = .infer(lhs_expr)
    assert! class_t is DataClassT
    return class_t
  end

  def infer(expr)
    if expr is NumExpr
      return new NumT()
    else if expr is StrExpr
      return new StrT()
    else if expr is ReturnExpr
      return .infer(expr.expr)
    else if expr is JsOpExpr
      return .infer_js_op(expr.type).return_type
    else if expr is IdLookup
      return .infer_id_lookup(expr)
    else if expr is FunctionCall
      return .infer(expr.lhs_expr).return_type
    else if expr is DotAccess
      return .infer_dot_access(expr)
    else if expr is ArrayLiteral
      return .infer_array_literal(expr)
    else if expr is NewExpr
      return .infer_new_expr(expr)
    else
      assert_not_reached! "Cant infer " + expr.constructor.name
    end
  end

  def infer_number_method(property)
    if property === "toString"
      return new FnT([], new StrT())
    else
      assert_not_reached! "unknown property `" + property + "` on num"
    end
  end

  def infer_array_method(arr_t, property)
    if property === "push"
      return new FnT([{ type: arr_t.type }], new NumT())
    else
      assert_not_reached! "unknown array method " + property
    end
  end

  def infer_array_literal({ elements })
    let types = elements.map(::infer).uniq_by(::is_match)
    if types.length === 1
      return new ArrayT(types[0])
    else
      return new ArrayT(new UnionT(types))
    end
  end

  def panic_mismatch(name, expected, got)
    assert_not_reached! "type mismatch: expected `" + name + "` to be a " + expected + " but it was a " + got 
  end


  def resolve(type)
    return type if type is not TypeIdLookup
    .types[type.name]
  end

  def is_match(a, b)
    a = .resolve(a)
    b = .resolve(b)
    if a is UnionT
      return a.types.some(type => .is_match(type, b))
    else if b is UnionT
      return .is_match(b, a)
    end
    a.constructor === b.constructor
  end

  def infer_js_op(type)
    if type === "+"
      return new FnT([{ type: new NumT() }, { type: new NumT() }], new NumT())
    else if type === "++"
      return new FnT([{ type: new StrT() }, { type: new StrT() }], new StrT())
    else
      assert_not_reached! "unknown js op type " + type
    end
  end

  def check_js_op_expr({ lhs, rhs, type })
      let lhs_t = .infer(lhs)
      let rhs_t = .infer(rhs)
      if !.is_match(lhs_t, rhs_t)
        console.log(lhs_t, rhs_t)
        assert_not_reached! "js operands don't match"
      end
      let { args, return_type } = .infer_js_op(type)
      if !.is_match(lhs_t, args[0].type)
        console.log(type, return_type)
        console.log(lhs_t, args[0].type)
        assert_not_reached! "js op arg type mismatch"
      end
      assert_not_reached! "js op return type mismatch" if !.is_match(lhs_t, return_type)
  end

  def check_expr(expr)
    if expr is FunctionCall
      .check_function_call(expr)
    else if expr is NumExpr
      null
    else if expr is StrExpr
      null
    else if expr is JsOpExpr
      .check_js_op_expr(expr)
    else if expr is ArrayLiteral
      .check_array_literal(expr)
    else if expr is IdLookup
      assert_not_reached! "can't find `" + expr.name + "`" if !.types[expr.name]
    else if expr is NewExpr
      .check_new_expr(expr)
    else if expr is DotAccess
      .check_dot_access(expr)
    else
      assert_not_reached! "check_expr: Unknown expr " + expr.constructor.name
    end
  end

  def check_dot_access({ lhs, property })
    console.log(lhs, property)
    let lhs_t = .infer(lhs)
    if lhs_t is DataClassT
      assert! lhs_t.properties.some(p => p[0] === property)
    else
      assert_not_reached! "Not able to dot access on " + lhs_t.constructor.name
    end
  end

  def check_new_expr({ expr })
    assert! expr is FunctionCall
    let { lhs_expr, args } = expr
    let class_t = .infer(lhs_expr)
    assert! class_t is DataClassT
    let { properties } = class_t
    for let iter of args.zip(properties) do
      let [arg, arg_t] = iter
      let [, type] = arg_t
      assert! .is_match(.infer(arg), type)
    end

    null
  end

  def check_array_literal({ elements })
    elements.map(::check_expr)
  end

  def pretty(obj)
    obj.constructor.name + "(" + JSON.stringify(obj) + ")"
  end

  def check_function_call({ lhs_expr, args })
    for let arg of args do
      .check_expr(arg)
    end
    let { args: fn_arg_types } = .infer(lhs_expr)
    return null if fn_arg_types is AnyT
    assert_not_reached! "args length mismatch" if fn_arg_types.length !== args.length

    for let iter of args.zip(fn_arg_types) do
      let [value, {type}] = iter
      if !.is_match(.infer(value), type)
        .panic_mismatch(.pretty(value), type.constructor.name, .infer(value).constructor.name)
      end
    end
    null
  end

  def check_named_let({ name, expr, type })
    type = .resolve(type)
    .check_expr(expr)
    let inferred_type = .infer(expr)
    if !type
      .types[name] = inferred_type
    else if .is_match(type, .infer(expr))
      .types[name] = type
    else
      console.log(name, type, .infer(expr))
      console.log(expr)
      .panic_mismatch(name, type.constructor.name, .infer(expr).constructor.name)
    end
  end
end

export default TypeChecker