import {
  IdLookup, NamedLet, NumExpr, FunctionCall, CommandExpr,
  JsOpExpr, FunctionDef, ReturnExpr, DataClassDef,
  NewExpr, DotAccess, ClassDef, ClassInstanceEntry,
  ClassGetterExpr, PrefixDotLookup, StrExpr,
  NotExpr, ArrayLiteral, IfStatement, NodeAssignment,
  NodePlusAssignment, WhileStatement, RegexNode,
  ContinueStatement, BreakStatement, IfBranch,
  ElseIfBranch, ElseBranch, PropertyLookup, ExportDefault,
  ExportStatement, SpreadExpr, SimpleArg, SpreadArg,
  ArrowFn, IsOperator, BoundFunctionDef, ForLoop,
  IsNotOperator, ParenExpr, LetObjectDeconstruction,
  RegularObjectProperty, RenamedProperty, ImportStatement,
  DefaultImport, LetArrDeconstruction, ArrNameEntry,
  ArrComma, DefaultObjClassArg, NamedClassArg, ObjClassArg,
  SimpleDefaultArg, ObjLit, SimpleObjEntry, PrefixBindLookup,
  NumberT, StrT
} from "./parser.mjs"

dataclass FnT(args, return_type)
dataclass AnyT
dataclass NilT
dataclass ObjT(properties)
dataclass ArrayT(type)
dataclass UnionT(types)

let BUILTIN_TYPES = {
  console: new ObjT({ log: new FnT(new AnyT(), new NilT()) })
  process: new ObjT({ argv: new ArrayT(new StrT()) })
}

class TypeChecker(ast, types = BUILTIN_TYPES)
  def check
    for let statement of .ast do
      .check_statement(statement)
    end
    null
  end

  def check_statement(node)  
    if node is NamedLet
      .check_named_let(node)
    else if node is FunctionDef
      .check_function_def(node)
    else if node is ReturnExpr
      .check_expr(node.expr)
    else if node is FunctionCall
      .check_function_call(node)
    else if node is LetArrDeconstruction
      .check_let_arr_deconstruction(node)
    else
      assert_not_reached! "Unknown statement " + node.constructor.name
    end
  end

  def check_let_arr_deconstruction({ entries, rhs })
    let { type } = .infer(rhs)
    for let entry of entries do
      continue if entry is ArrComma
      if entry is ArrNameEntry
        .types[entry.name] = type
      else
        console.log(entry)
        assert_not_reached! "unknown array entry " + entry.constructor.name
      end
    end
    null
  end

  def check_function_def({ name, args, body, type })
    let sub_types = Object.assign({}, .types)
    let tc = new TypeChecker(body, sub_types)
    # infer the returned type
    # TODO: look at all return statements, not just the last one
    type = tc.infer(body.at(-1)) if !type
    # store the type
    .types[name] = new FnT(args, type)
    # store the arg types
    for let arg of args do
      sub_types[arg.name] = arg.type
    end
    # type check the function body
    tc.check()
  end

  def infer(expr)
    if expr is NumExpr
      return new NumberT()
    else if expr is StrExpr
      return new StrT()
    else if expr is ReturnExpr
      return .infer(expr.expr)
    else if expr is JsOpExpr
      return .infer_js_op(expr.type).return_type
    else if expr is IdLookup      
      return .types[expr.name] if .types[expr.name]
      # fail
      console.log(expr)
      assert_not_reached! "unknown type for " + expr.name
    else if expr is FunctionCall
      return .infer(expr.lhs_expr).return_type
    else if expr is DotAccess
      let lhs_t = .infer(expr.lhs)
      if lhs_t is ArrayT
        return .infer_array_method(lhs_t, expr.property)
      else if lhs_t is ObjT
        return .infer(expr.lhs).properties[expr.property]
      else if lhs_t is NumberT
        return .infer_number_method(expr.property)
      else
        assert_not_reached! "unknown lhs of dot access " ++ lhs_t.constructor.name
      end
    else if expr is ArrayLiteral
      return .infer_array_literal(expr)
    else
      assert_not_reached! "Cant infer " + expr.constructor.name
    end
  end

  def infer_number_method(property)
    if property === "toString"
      return new FnT([], new StrT())
    else
      assert_not_reached! "unknown property `" + property + "` on number"
    end
  end

  def infer_array_method(arr_t, property)
    if property === "push"
      return new FnT([{ type: arr_t.type }], new NumberT())
    else
      assert_not_reached! "unknown array method " + property
    end
  end

  def infer_array_literal({ elements })
    let types = elements.map(::infer).uniq_by(::is_match)
    if types.length === 1
      return new ArrayT(types[0])
    else
      return new ArrayT(new UnionT(types))
    end
  end

  def panic_mismatch(name, expected, got)
    assert_not_reached! "type mismatch: expected `" + name + "` to be a " + expected + " but it was a " + got 
  end

  def is_match(a, b)
    if a is UnionT
      return a.types.some(type => .is_match(type, b))
    else if b is UnionT
      return .is_match(b, a)
    end
    a.constructor === b.constructor
  end

  def infer_js_op(type)
    if type === "+"
      return new FnT([{ type: new NumberT() }, { type: new NumberT() }], new NumberT())
    else if type === "++"
      return new FnT([{ type: new StrT() }, { type: new StrT() }], new StrT())
    else
      assert_not_reached! "unknown js op type " + type
    end
  end

  def check_js_op_expr({ lhs, rhs, type })
      let lhs_t = .infer(lhs)
      let rhs_t = .infer(rhs)
      if !.is_match(lhs_t, rhs_t)
        console.log(lhs_t, rhs_t)
        assert_not_reached! "js operands don't match"
      end
      let { args, return_type } = .infer_js_op(type)
      if !.is_match(lhs_t, args[0].type)
        console.log(type, return_type)
        console.log(lhs_t, args[0].type)
        assert_not_reached! "js op arg type mismatch"
      end
      assert_not_reached! "js op return type mismatch" if !.is_match(lhs_t, return_type)
  end

  def check_expr(expr)
    if expr is FunctionCall
      .check_function_call(expr)
    else if expr is NumExpr
      null
    else if expr is StrExpr
      null
    else if expr is JsOpExpr
      .check_js_op_expr(expr)
    else if expr is ArrayLiteral
      .check_array_literal(expr)
    else if expr is IdLookup
      assert_not_reached! "can't find `" + expr.name + "`" if !.types[expr.name]
    else
      assert_not_reached! "check_expr: Unknown nodeÂ " + expr.constructor.name
    end
  end

  def check_array_literal({ elements })
    elements.map(::check_expr)
  end

  def pretty(obj)
    obj.constructor.name + "(" + JSON.stringify(obj) + ")"
  end

  def check_function_call({ lhs_expr, args })
    for let arg of args do
      .check_expr(arg)
    end
    let { args: fn_arg_types } = .infer(lhs_expr)
    return null if fn_arg_types is AnyT
    assert_not_reached! "args length mismatch" if fn_arg_types.length !== args.length

    for let iter of args.zip(fn_arg_types) do
      let [value, {type}] = iter
      if !.is_match(.infer(value), type)
        .panic_mismatch(.pretty(value), type.constructor.name, .infer(value).constructor.name)
      end
    end
    null
  end

  def check_named_let({ name, expr, type })
    .check_expr(expr)
    let inferred_type = .infer(expr)
    if !type
      .types[name] = inferred_type
    else if .is_match(type, .infer(expr))
      .types[name] = type
    else
      console.log(name, type, .infer(expr))
      console.log(expr)
      .panic_mismatch(name, type.constructor.name, .infer(expr).constructor.name)
    end
  end
end

export default TypeChecker