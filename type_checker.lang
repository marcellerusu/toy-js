import {
  IdLookup, NamedLet, NumExpr, FunctionCall, CommandExpr,
  JsOpExpr, FunctionDef, ReturnExpr, DataClassDef,
  NewExpr, DotAccess, ClassDef, ClassInstanceEntry,
  ClassGetterExpr, PrefixDotLookup, StrExpr,
  NotExpr, ArrayLiteral, IfStatement, NodeAssignment,
  NodePlusAssignment, WhileStatement, RegexNode,
  ContinueStatement, BreakStatement, IfBranch,
  ElseIfBranch, ElseBranch, PropertyLookup, ExportDefault,
  ExportStatement, SpreadExpr, SimpleArg, SpreadArg,
  ArrowFn, IsOperator, BoundFunctionDef, ForLoop,
  IsNotOperator, ParenExpr, LetObjectDeconstruction,
  RegularObjectProperty, RenamedProperty, ImportStatement,
  DefaultImport, LetArrDeconstruction, ArrNameEntry,
  ArrComma, DefaultObjClassArg, NamedClassArg, ObjClassArg,
  SimpleDefaultArg, ObjLit, SimpleObjEntry, PrefixBindLookup,
  NumberT, StrT
} from "./parser.mjs"

dataclass FnT(args, return_type)
dataclass AnyT
dataclass NilT
dataclass ObjT(properties)

let BUILTIN_TYPES = {
  console: new ObjT({ log: new FnT(new AnyT(), new NilT()) })
}

class TypeChecker(ast, types = BUILTIN_TYPES)
  def check
    for let statement of .ast do
      .check_statement(statement)
    end
    null
  end

  def check_statement(node)  
    if node is NamedLet
      .check_named_let(node)
    else if node is FunctionDef
      .check_function_def(node)
    else if node is ReturnExpr
      .check_expr(node.expr)
    else if node is FunctionCall
      .check_function_call(node)
    else
      assert_not_reached! "Unknown statement " + node.constructor.name
    end
  end

  def check_function_def({ name, args, body, type })
    .types[name] = new FnT(args, type)
    let sub_types = Object.assign({}, .types)
    for let arg of args do
      sub_types[arg.name] = arg.type
    end
    new TypeChecker(body, sub_types).check()
  end

  def infer(expr)
    if expr is NumExpr
      return new NumberT()
    else if expr is StrExpr
      return new StrT()
    else if expr is IdLookup
      assert_not_reached! "unknown type for " + expr.name if !.types[expr.name]
      return .types[expr.name]
    else if expr is FunctionCall
      return .infer(expr.lhs_expr).return_type
    else if expr is DotAccess
      return .infer(expr.lhs).properties[expr.property]
    else
      assert_not_reached! "Can't infer " + expr.constructor.name
    end
  end

  def panic_mismatch(name, expected, got)
    assert_not_reached! "type mismatch: expected `" + name + "` to be a " + expected + " but it was a " + got 
  end

  def is_match(a, b)
    a.constructor === b.constructor
  end

  def infer_js_op(type)
    if type === "+"
      return new FnT([{ type: new NumberT() }, { type: new NumberT() }], new NumberT())
    else
      assert_not_reached! "unknown js op type " + type
    end
  end

  def check_js_op_expr({ lhs, rhs, type })
      let lhs_t = .infer(lhs)
      let rhs_t = .infer(rhs)
      assert_not_reached! "js operands don't match" if !.is_match(lhs_t, rhs_t)
      let { args, return_type } = .infer_js_op(type)
      assert_not_reached! "js op arg type mismatch" if !.is_match(lhs_t, args[0].type)
      assert_not_reached! "js op return type mismatch" if !.is_match(lhs_t, return_type)
  end

  def check_expr(expr)
    if expr is FunctionCall
      .check_function_call(expr)
    else if expr is NumExpr
      null
    else if expr is StrExpr
      null
    else if expr is JsOpExpr
      .check_js_op_expr(expr)
    else
      assert_not_reached! "check_expr: Unknown nodeÂ " + expr.constructor.name
    end
  end

  def pretty(obj)
    obj.constructor.name + "(" + JSON.stringify(obj) + ")"
  end

  def check_function_call({ lhs_expr, args })
    for let arg of args do
      .check_expr(arg)
    end
    let { args: fn_arg_types } = .infer(lhs_expr)
    return null if fn_arg_types is AnyT
    assert_not_reached! "args length mismatch" if fn_arg_types.length !== args.length

    for let iter of args.zip(fn_arg_types) do
      let [value, {type}] = iter
      if !.is_match(.infer(value), type)
        .panic_mismatch(.pretty(value), type.constructor.name, .infer(value).constructor.name)
      end
    end
    null
  end

  def check_named_let({ name, expr, type })
    .check_expr(expr)
    let inferred_type = .infer(expr)
    if !type
      .types[name] = inferred_type
    else if .is_match(type, .infer(expr))
      .types[name] = type
    else
      console.log(name, type, .infer(expr))
      console.log(expr)
      .panic_mismatch(name, type.constructor.name, .infer(expr).constructor.name)
    end
  end
end

export default TypeChecker