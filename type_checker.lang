import {
  IdLookup, NamedLet, NumExpr, FunctionCall, CommandExpr,
  JsOpExpr, FunctionDef, ReturnExpr, DataClassDef,
  NewExpr, DotAccess, ClassDef, ClassInstanceEntry,
  ClassGetterExpr, PrefixDotLookup, StrExpr,
  NotExpr, ArrayLiteral, IfStatement, NodeAssignment,
  NodePlusAssignment, WhileStatement, RegexNode,
  ContinueStatement, BreakStatement, IfBranch,
  ElseIfBranch, ElseBranch, PropertyLookup, ExportDefault,
  ExportStatement, SpreadExpr, SimpleArg, SpreadArg,
  ArrowFn, IsOperator, BoundFunctionDef, ForLoop,
  IsNotOperator, ParenExpr, LetObjectDeconstruction,
  RegularObjectProperty, RenamedProperty, ImportStatement,
  DefaultImport, LetArrDeconstruction, ArrNameEntry,
  ArrComma, DefaultObjClassArg, NamedClassArg, ObjClassArg,
  SimpleDefaultArg, ObjLit, SimpleObjEntry, PrefixBindLookup,
  NumberT, StrT
} from "./parser.mjs"

dataclass FnT(args, return_type)

class TypeChecker(ast, types = {})
  def check
    for let statement of .ast do
      .check_statement(statement)
    end
    null
  end

  def check_statement(node)  
    if node is NamedLet
      .check_named_let(node)
    else if node is FunctionDef
      .check_function_def(node)
    else if node is ReturnExpr
      .check_expr(node.expr)
    else
      assert_not_reached! "Unknown node " + node.constructor.name
    end
  end

  def check_function_def({ name, args, body, type })
    .types[name] = new FnT(args, type)
    let sub_types = structuredClone(.types)
    for let arg of args do
      sub_types[arg.name] = arg.type
    end
    new TypeChecker(body, sub_types).check()
  end

  def infer(expr)
    if expr is NumExpr
      return new NumberT()
    else if expr is StrExpr
      return new StrT()
    else if expr is IdLookup
      return .types[expr.name]
    else if expr is FunctionCall
      return .infer(expr.lhs_expr).return_type
    else
      assert_not_reached! "Can't infer " + expr.constructor.name
    end
  end

  def panic_mismatch(name, expected, got)
    assert_not_reached! "type mismatch: expected `" + name + "` to be a " + expected + " but it was a " + got 
  end

  def is_match(a, b)
    a.constructor === b.constructor
  end

  def infer_js_op(type)
    if type === "+"
      return new FnT([{ type: new NumberT() }, { type: new NumberT() }], new NumberT())
    else
      assert_not_reached! "unknown js op type " + type
    end
  end

  def check_expr(expr)
    if expr is FunctionCall
      .check_function_call(expr)
    else if expr is JsOpExpr
      let lhs = .infer(expr.lhs)
      let rhs = .infer(expr.rhs)
      assert_not_reached! "js operands don't match" if !.is_match(lhs, rhs)
      let { args, return_type } = .infer_js_op(expr.type)
      assert_not_reached! "js op arg type mismatch" if !.is_match(lhs, args[0].type)
      assert_not_reached! "js op return type mismatch" if !.is_match(lhs, return_type)
    else
      assert_not_reached! "check_expr: Unknown nodeÂ " + expr.constructor.name
    end
  end

  def pretty(obj)
    obj.constructor.name + "(" + JSON.stringify(obj) + ")"
  end

  def check_function_call({ lhs_expr, args })
    let { args: fn_arg_types } = .infer(lhs_expr)
    for let iter of args.zip(fn_arg_types) do
      let [value, {type}] = iter
      if !.is_match(.infer(value), type)
        .panic_mismatch(.pretty(value), type.constructor.name, .infer(value).constructor.name)
      end
    end
    null
  end

  def check_named_let({ name, expr, type })
    console.log(expr)
    .check_expr(expr)
    console.log(name, type, .infer(expr))
    if .is_match(type, .infer(expr))
      null
    else
      .panic_mismatch(name, type.constructor.name, .infer(expr))
    end
  end
end

export default TypeChecker