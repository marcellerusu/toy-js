export dataclass Id(line, name)
export dataclass Num(line, value, is_negative)
export dataclass Command(line, name)
export dataclass Str(line, value)
export dataclass Regex(line, value)
export dataclass JsOp(line, op)
export dataclass Let(line)
export dataclass Eq(line)
export dataclass PlusEq(line)
export dataclass OpenParen(line)
export dataclass CloseParen(line)
export dataclass Comma(line)
export dataclass Def(line)
export dataclass End(line)
export dataclass Return(line)
export dataclass DataClass(line)
export dataclass New(line)
export dataclass Dot(line)
export dataclass Class(line)
export dataclass Get(line)
export dataclass Bang(line)
export dataclass OpenSquare(line)
export dataclass CloseSquare(line)
export dataclass If(line)
export dataclass Else(line)
export dataclass Or(line)
export dataclass And(line)
export dataclass TripleEq(line)
export dataclass NotTripleEq(line)
export dataclass While(line)
export dataclass Break(line)
export dataclass Continue(line)
export dataclass Do(line)
export dataclass Export(line)
export dataclass Default(line)
export dataclass Spread(line)
export dataclass Arrow(line)
export dataclass Bind(line)
export dataclass Is(line)
export dataclass Not(line)
export dataclass For(line)
export dataclass Of(line)
export dataclass OpenBrace(line)
export dataclass CloseBrace(line)
export dataclass Colon(line)
export dataclass Import(line)
export dataclass From(line)

class Lexer(str)
  index = 0
  get rest_of_string = .str.slice(.index)
  get cur = .str[.index]

  matched = null
  def scan(regex)
    let result = .rest_of_string.match(regex)
    return false if !result || result.index !== 0
    .index += result[0].length
    .matched = result[0]
    return true
  end

  def parse_str
    let str = ""
    .index += 1
    while
      .cur !== "\"" ||
      (.str[.index - 1] === "\\" && .str[.index - 2] !== "\\")
    do
      str += .cur
      .index += 1
      assert_not_reached! "no new lines" if .cur === "\n"
    end
    .index += 1
    return str
  end

  def tokenize
    let tokens = []
    let line = 0
    while .index < .str.length do
      if .scan(/\n/)
        line += 1
        continue
      else if .scan(/\s+/)
        continue
      else if .scan(/#.*/)
        continue
      else if .scan(/let\b/)
        tokens.push(new Let(line))
      else if .scan(/while\b/)
        tokens.push(new While(line))
      else if .scan(/export\b/)
        tokens.push(new Export(line))
      else if .scan(/import\b/)
        tokens.push(new Import(line))
      else if .scan(/from\b/)
        tokens.push(new From(line))
      else if .scan(/default\b/)
        tokens.push(new Default(line))
      else if .scan(/do\b/)
        tokens.push(new Do(line))
      else if .scan(/for\b/)
        tokens.push(new For(line))
      else if .scan(/of\b/)
        tokens.push(new Of(line))
      else if .scan(/\/.*\//)
        tokens.push(new Regex(line, .matched))
      else if .scan(/continue\b/)
        tokens.push(new Continue(line))
      else if .scan(/break\b/)
        tokens.push(new Break(line))
      else if .scan(/def\b/)
        tokens.push(new Def(line))
      else if .scan(/if\b/)
        tokens.push(new If(line))
      else if .scan(/else\b/)
        tokens.push(new Else(line))
      else if .scan(/end\b/)
        tokens.push(new End(line))
      else if .scan(/return\b/)
        tokens.push(new Return(line))
      else if .scan(/dataclass\b/)
        tokens.push(new DataClass(line))
      else if .cur === "\""
        let parsed_str = .parse_str()
        tokens.push(new Str(line, parsed_str))
      else if .scan(/class\b/)
        tokens.push(new Class(line))
      else if .scan(/get\b/)
        tokens.push(new Get(line))
      else if .scan(/new\b/)
        tokens.push(new New(line))
      else if .scan(/is\b/)
        tokens.push(new Is(line))
      else if .scan(/not\b/)
        tokens.push(new Not(line))
      else if .scan(/\.\.\./)
        tokens.push(new Spread(line))
      else if .scan(/\./)
        tokens.push(new Dot(line))
      else if .scan(/\(/)
        tokens.push(new OpenParen(line))
      else if .scan(/\)/)
        tokens.push(new CloseParen(line))
      else if .scan(/\[/)
        tokens.push(new OpenSquare(line))
      else if .scan(/\]/)
        tokens.push(new CloseSquare(line))
      else if .scan(/\{/)
        tokens.push(new OpenBrace(line))
      else if .scan(/\}/)
        tokens.push(new CloseBrace(line))
      else if .scan(/,/)
        tokens.push(new Comma(line))
      else if .scan(/[a-zA-Z_]+\!/)
        tokens.push(new Command(line, .matched))
      else if .scan(/[a-zA-Z_]+/)
        tokens.push(new Id(line, .matched))
      else if .scan(/\+=/)
        tokens.push(new PlusEq(line))
      else if .scan(/[0-9]+/)
        tokens.push(new Num(line, Number(.matched)))
      else if .scan(/-[0-9]+/)
        tokens.push(new Num(line, Number(.matched), true))
      else if .scan(/\+\+/)
        tokens.push(new JsOp(line, "++"))
      else if .scan(/\>=|\<=|[\+\-\*\/\%\<\>]|&&|\|\||===|!==/)
        tokens.push(new JsOp(line, .matched))
      else if .scan(/=>/)
        tokens.push(new Arrow(line))
      else if .scan(/::/)
        tokens.push(new Bind(line))
      else if .scan(/:/)
        tokens.push(new Colon(line))
      else if .scan(/=/)
        tokens.push(new Eq(line))
      else if .scan(/\!/)
        tokens.push(new Bang(line))
      else
        assert_not_reached! "nothing found"
      end
    end
    return tokens
  end
end


export default Lexer