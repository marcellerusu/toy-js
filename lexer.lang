dataclass Id(line, name)
dataclass Command(line, name)
dataclass Num(line, value)
dataclass Str(line, value)
dataclass Regex(line, value)
dataclass JsOp(line, op)
dataclass Let(line)
dataclass Eq(line)
dataclass PlusEq(line)
dataclass OpenParen(line)
dataclass CloseParen(line)
dataclass Comma(line)
dataclass Def(line)
dataclass End(line)
dataclass Return(line)
dataclass DataClass(line)
dataclass New(line)
dataclass Dot(line)
dataclass Class(line)
dataclass Get(line)
dataclass Bang(line)
dataclass OpenSquare(line)
dataclass CloseSquare(line)
dataclass If(line)
dataclass Else(line)
dataclass Or(line)
dataclass And(line)
dataclass TripleEq(line)
dataclass NotTripleEq(line)
dataclass While(line)
dataclass Break(line)
dataclass Continue(line)
dataclass Do(line)

class Lexer(str)
  index = 0
  get rest_of_string = .str.slice(.index)

  matched = null
  def scan(regex)
    let result = .rest_of_string.match(regex)
    return false if !result || result.index !== 0
    .index += result[0].length
    .matched = result[0]
    return true
  end

  def tokenize
    let tokens = []
    let line = 0
    while .index < .str.length do
      if .scan(/\n/)
        line += 1
        continue
      else if .scan(/\s+/)
        continue
      else if .scan(/let/)
        tokens.push(new Let(line))
      else if .scan(/while/)
        tokens.push(new While(line))
      else if .scan(/do/)
        tokens.push(new Do(line))
      else if .scan(/\/.*\//)
        tokens.push(new Regex(line, .matched))
      else if .scan(/continue/)
        tokens.push(new Continue(line))
      else if .scan( /break/)
        tokens.push(new Break(line))
      else if .scan(/def/)
        tokens.push(new Def(line))
      else if .scan(/if/)
        tokens.push(new If(line))
      else if .scan(/else/)
        tokens.push(new Else(line))
      else if .scan(/end/)
        tokens.push(new End(line))
      else if .scan(/return/)
        tokens.push(new Return(line))
      else if .scan(/dataclass/)
        tokens.push(new DataClass(line))
      else if .scan(/".*"/)
        tokens.push(new Str(line, .matched.slice(1, -1)))
      else if .scan(/class/)
        tokens.push(new Class(line))
      else if .scan(/get/)
        tokens.push(new Get(line))
      else if .scan(/new/)
        tokens.push(new New(line))
      else if .scan(/\./)
        tokens.push(new Dot(line))
      else if .scan(/\(/)
        tokens.push(new OpenParen(line))
      else if .scan(/\)/)
        tokens.push(new CloseParen(line))
      else if .scan(/\[/)
        tokens.push(new OpenSquare(line))
      else if .scan(/\]/)
        tokens.push(new CloseSquare(line))
      else if .scan(/,/)
        tokens.push(new Comma(line))
      else if .scan(/[a-zA-Z_]+\!/)
        tokens.push(new Command(line, .matched))
      else if .scan(/[a-zA-Z_]+/)
        tokens.push(new Id(line, .matched))
      else if .scan(/\+=/)
        tokens.push(new PlusEq(line))
      else if .scan(/[\+\-\*\/\%\<\>]|>=|<=|&&|\|\||===|!==/)
        tokens.push(new JsOp(line, .matched))
      else if .scan(/=/)
        tokens.push(new Eq(line))
      else if .scan(/\!/)
        tokens.push(new Bang(line))
      else if .scan(/[0-9]+/)
        tokens.push(new Num(line, Number(.matched)))
      else
        console.error("oh no")
      end
    end
    return tokens
  end
end


