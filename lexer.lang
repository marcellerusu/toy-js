export dataclass Id(line, name)
export dataclass Num(line, value, is_negative)
export dataclass Command(line, name)
export dataclass Str(line, value)
export dataclass Regex(line, value)
export dataclass JsOp(line, op)
export dataclass Let(line)
export dataclass Eq(line)
export dataclass PlusEq(line)
export dataclass OpenParen(line)
export dataclass CloseParen(line)
export dataclass Comma(line)
export dataclass Def(line)
export dataclass End(line)
export dataclass Return(line)
export dataclass DataClass(line)
export dataclass New(line)
export dataclass Dot(line)
export dataclass Class(line)
export dataclass Get(line)
export dataclass Bang(line)
export dataclass OpenSquare(line)
export dataclass CloseSquare(line)
export dataclass If(line)
export dataclass Else(line)
export dataclass Or(line)
export dataclass And(line)
export dataclass TripleEq(line)
export dataclass NotTripleEq(line)
export dataclass While(line)
export dataclass Break(line)
export dataclass Continue(line)
export dataclass Do(line)
export dataclass Export(line)
export dataclass Default(line)


class Lexer(str)
  index = 0
  get rest_of_string = .str.slice(.index)

  matched = null
  def scan(regex)
    let result = .rest_of_string.match(regex)
    return false if !result || result.index !== 0
    .index += result[0].length
    .matched = result[0]
    return true
  end

  def tokenize
    let tokens = []
    let line = 0
    while .index < .str.length do
      if .scan(/\n/)
        line += 1
        continue
      else if .scan(/\s+/)
        continue
      else if .scan(/let/)
        tokens.push(new Let(line))
      else if .scan(/while/)
        tokens.push(new While(line))
      else if .scan(/export/)
        tokens.push(new Export(line))
      else if .scan(/default/)
        tokens.push(new Default(line))
      else if .scan(/do/)
        tokens.push(new Do(line))
      else if .scan(/\/.*\//)
        tokens.push(new Regex(line, .matched))
      else if .scan(/continue/)
        tokens.push(new Continue(line))
      else if .scan( /break/)
        tokens.push(new Break(line))
      else if .scan(/def/)
        tokens.push(new Def(line))
      else if .scan(/if/)
        tokens.push(new If(line))
      else if .scan(/else/)
        tokens.push(new Else(line))
      else if .scan(/end/)
        tokens.push(new End(line))
      else if .scan(/return/)
        tokens.push(new Return(line))
      else if .scan(/dataclass/)
        tokens.push(new DataClass(line))
      else if .scan(/".*"/)
        tokens.push(new Str(line, .matched.slice(1, -1)))
      else if .scan(/class/)
        tokens.push(new Class(line))
      else if .scan(/get/)
        tokens.push(new Get(line))
      else if .scan(/new/)
        tokens.push(new New(line))
      else if .scan(/\./)
        tokens.push(new Dot(line))
      else if .scan(/\(/)
        tokens.push(new OpenParen(line))
      else if .scan(/\)/)
        tokens.push(new CloseParen(line))
      else if .scan(/\[/)
        tokens.push(new OpenSquare(line))
      else if .scan(/\]/)
        tokens.push(new CloseSquare(line))
      else if .scan(/,/)
        tokens.push(new Comma(line))
      else if .scan(/[a-zA-Z_]+\!/)
        tokens.push(new Command(line, .matched))
      else if .scan(/[a-zA-Z_]+/)
        tokens.push(new Id(line, .matched))
      else if .scan(/\+=/)
        tokens.push(new PlusEq(line))
      else if .scan(/[0-9]+/)
        tokens.push(new Num(line, Number(.matched)))
      else if .scan(/-[0-9]+/)
        tokens.push(new Num(line, Number(.matched), true))
      else if .scan(/[\+\-\*\/\%\<\>]|>=|<=|&&|\|\||===|!==/)
        tokens.push(new JsOp(line, .matched))
      else if .scan(/=/)
        tokens.push(new Eq(line))
      else if .scan(/\!/)
        tokens.push(new Bang(line))
      else
        console.error("oh no")
      end
    end
    return tokens
  end
end


export default Lexer